CREATE TABLE BOOKS (
    BOOK_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    TITLE VARCHAR2(200) NOT NULL,
    AUTHOR VARCHAR2(100),
    CATAGORY VARCHAR2(100), -- 'catagory' 오타가 아닌지 확인 (CATEGORY?)
    ISBN VARCHAR2(13),
    PRICE NUMBER,
    PUBLISHED_DATE DATE,
    CREATED_BY VARCHAR2(50) NOT NULL,
    CREATED_AT DATE DEFAULT SYSDATE,
    UPDATE_BY VARCHAR2(50) NOT NULL,
    UPDATE_AT DATE DEFAULT SYSDATE
);

-- 조회
SELECT * FROM BOOKS ORDER BY BOOK_ID DESC;

-- 삽입
INSERT INTO BOOKS (
    TITLE, AUTHOR, CATAGORY, ISBN, PRICE, PUBLISHED_DATE, CREATED_BY, UPDATE_BY
) VALUES (
    '제목', '저자', '소설', '443223', 10000, TO_DATE('2025-01-01', 'YYYY-MM-DD'), '임꺽정', '김도'
);
-- 변경
UPDATE BOOKS SET 
    TITLE = '제목변경'
    , AUTHOR = '저자 변경'
    , CATAGORY = '카테고리 변경'
    , ISBN = '566554'
    , PRICE = 20000
    , PUBLISHED_DATE = '2025-02-02'
    , CREATED_BY = '정우'
    , UPDATE_BY = '우정'
    , UPDATE_AT = SYSDATE
    WHERE BOOK_ID = 1;
-- 삭제
DELETE FROM BOOKS WHERE BOOK_ID = 1;

commit;

-- 프로시저 Procedure
/* 미리 컴파일된 sql 문들의 집합 
CALL 프로시저명 : 방식으로 실행

장점
1. 성능 향상 : 컴파일 되어있음
2. 재사용성 : 여러 곳에서 동일한 프로시저 호출
3. 유지보수 용이 : 로직이 DB안에 있어서 변경이 용이
4. 트랜잭션 제어 용이 : 여러 쿼리를 하나의 트랜잭션으로 처리 가능

단점
1. 복잡한 로직에는 사용이 어렵다 : 절차 지향적이다
2. 이식성 문제 : DBMS마다 문법차이가 있다.
3. 디버깅이 어렵다 : 로그가 없다.
4. 버전관리 불가 : git 사용불가

sql 쿼리 실행 과정
1. 파싱 : 문법 검사
2. 쿼리 구조 분석 : 컴파일 > 실행 계획 생성 > 어떤 인덱스를 쓸건지, 어떤 순서로 조인할건지 전략결정
3. 실행 
*/